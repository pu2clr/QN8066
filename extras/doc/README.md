# Various subjects related to the contents of this repository


1. [About RDS]()
2. [Practical Guide to Building an Inductor Using Copper Wire]()


## Packaging and transmitting RDS messages using the QN8066

By Ricardo Lima Caratti - 2024

### Introduction 

The growing popularity of Arduino and the need for a more accessible development platform for the QN8066 microcontroller motivated the development of this library (PU2CLR QN8066 Arduino Library). By providing an intuitive and familiar interface to Arduino users, this library aims to democratize access to the QN8066 and streamline the development of projects involving FM radio transmissions with additional information via RDS.

The Radio Data System (RDS) allows digital information to be transmitted alongside traditional FM radio broadcasts. To effectively send RDS data, such as station names, it's essential to understand the specific structure and bit sequences involved. This paper presents a study on the implementation of the Radio Data System (RDS) using the QN8066 microcontroller. The study addresses the methodology for packaging and transmitting additional digital information, such as the station name, along with the FM radio signal. To this end, the structure of RDS data and the configuration of the QN8066 to generate and transmit these packets efficiently are detailed.

### RDS Message Format


#### Basic Concepts

Before starting with the information that will help implement the RDS functions for the QN8066, it is important to understand some terms and concepts.

Block: A block is the basic unit of data in RDS. Each block contains 26 bits of useful data and 10 error-checking bits, totaling 36 bits. From the perspective of the QN8066, it is important to highlight that, for implementation purposes, only the first 16 bits are used, with the remaining bits being handled or generated by the QN8066 itself for internal control.

Group: A group is a collection of four blocks that together form a complete RDS message. There are different types of groups, each designated for different types of data and applications.

#### Block Structure

Each block in RDS has the following structure:

|    Bits     |  Description   |          
| ----------- | -------------- |                    
|  0-15	      | Useful data (16 bits)   |
|  16-25      | Checksum (10 bits) for error checking |
|  26-35      |	Synchronization bits (not included in the block's data but part of the transmission structure) |
| 



#### Types of Blocks

| Block  | Description |
| ------ | ----------- |
|   1    | Contains the Program Identification (PI) code |
|   2    | Contains the group application code and other variable information depending on the group type |
|   3    | May contain additional data or repeat the PI code, depending on the group type and version |
|   4    | Contains the specific data for the RDS service (e.g., station name) |


### Structure and Function of Each Block in Specific Groups


#### Block 1: Program Identification (PI) Code

| Bits  | Description | 
| ----  | ----------- | 
| 0-15  | PI Code - a unique identifier for the radio station |
| 16-25 | Checksum (error-checking code calculated internally by the QN8066) |

PI Code Function: Identifies the radio station. This code is essential for allowing receivers to identify the source of the radio signal.

**You don't need to calculate the Checksum to implement RDS services on the QN8066. This control is handled by the QN8066 itself. Basically, all you need to do is correctly fill in the PI Code.**


#### Block 2: Group Application Code and Variable Information

| Bits  | Description | 
| ----  | ----------- | 
| 0-3	| Group Type Code (A3, A2, A1, A0) |
|  4	| Group Version Code (B0) |
|  5	| Traffic Program Indicator (TP) |
| 6-10	| Program Type Code (PTY) |
| 11-15	| Additional data (variable depending on the group) |


Function: Specifies the type of data being transmitted and includes information such as program type (e.g., news, music) and whether the station transmits traffic information.



## Practical Guide to Building an Inductor Using Copper Wire

To create inductor using copper wire, you can follow a practical approach. The inductance of an inductor depends on factors such as the number of turns, the coil diameter, and the coil length. Here's a basic method to calculate and build your inductor:

### Inductance formula for an air-core coil

![Inductance formula for an air-core coil](./Inductance_formula_for_an%20air_core_coil.png)


Where:
- \(L\) is the inductance in microhenries (\(\mu H\)),
- \(r\) is the radius of the coil in inches,
- \(N\) is the number of turns,
- \(l\) is the length of the coil in inches.

### Determine the wire and coil form

- **Choose the wire diameter**: Thin wire, like enameled copper wire (22 AWG or 24 AWG), is recommended for winding small coils.
- **Coil radius**: Choose a cylindrical object with the desired diameter (e.g., a pen or a screw) to use as a mold.

### Choose approximate dimensions

For such a small inductance, you can try a **radius of 3 to 5 mm (0.12 to 0.2 inches)** and a low number of turns.

### Experimental adjustment

Building such small inductors often requires fine adjustments. The final inductance can vary depending on how tightly the wire is wound and other factors like tension.

### Tools to measure inductance

Use an inductance meter (LCR meter) to check the inductance value. If you donâ€™t reach 150 nH initially, you can adjust the number of turns or the coil diameter.

### Practical Example

- If you use a mold with a **5 mm diameter** (0.2 inches) and wind about **5 to 7 turns**, you should be close to achieving a 150 nH inductance.

You can also simulate these parameters using an [online inductor calculator](https://www.translatorscafe.com/unit-converter/pt-BR/calculator/coil-inductance/#google_vignette) or make experimental adjustments based on your measurements.

